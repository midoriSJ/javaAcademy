@ getter / setter
접근제어자 -> private : 캡슐화
객체의 필드를 객체의 내부뿐만 아니라 객체 밖에서도 마음껏 생성자를 통해서 사용할 수 있게 되었다.
필도를 보호하는 검증된 필드를 대입할 수 있으며 외부에서 사용할 필드값을 정제한 후 값을 제공받는다.

1) Setter 메서드
생성자의 입력된 값을 사용하기 전에 검증을 하고싶다.
필드 접근을 제한할 수 있다.

2) Getter 메서드
private한 필드를 객체 외부에서 값을 불러오기 위해 구현하는 메서드
메서드를 통해서만 값을 전달받을 수 있다.

@ 생성자 : overroading
객체를 생성할 때 호출되어 객체의 초기화를 담당한다.
특별한 메서드이고 라이브러리용 클래스는 모든 생성자를 가지고 있다.
-> 여러가지 객체를 마음껏 만든다
(클래스(클래스메서드 : 자동 호출) -> 객체1, 객체2, 객체3)
: 멤버변수 / 멤버 메서드 : 초기화 시킬 수 있다

1) 생성자 호출위치
생성자는 클래스를 기반으로 객체를 생성할 때 객체의 초기화를 담당하는 역할이므로
객체를 생성할 때에만 호출할 수 있다.

2) 기본 생성자
모든 클래스에는 하나 이상(오버로딩)의 생성자가 정의되어 있으며 클래스를 생성하면서
생성자를 선언하지는 않았지만 컴파일러가 기본 생성자를 자동으로 제공한다.
인스턴스 초기화 작업이 요구되지 않는다면 생성자를 정의하지 않아도 되고
컴파일러가 제공하는 기본 생성자를 사용하는 것이 좋다.
(= 자율적이지만 프로그래머가 세부적인 클래스를 설계할 경우 사용된다.)

3) 생성자 선언 이유
클래스 -> 객체 초기화 -> 메모리(객체) : 멤버 변수 / 멤버 메서드 

1. 생성자의 이름은 클래스의 이름과 같다.
2. 생성자는 리턴값이 없다. (선택의 여지 없음)
3. 생성자도 오버로딩이 가능하고 여러 개의 생성자를 만든다.

@ 생성자 오버로딩

1) 오버로딩
생성자를 다양한 매개변수의 형태로 선언할 수 있으며 다양성을 제공할 수 있다.
오버로딩은 다형성과 상속에 영향을 끼친다.

2) 생성자 오버로딩 종류
- 매개변수의 초기화가 부족할 경우 다양한 기본생성자를 만들 수 있다.
- 매개변수의 개수가 똑같더라도 데이터형이 다르면 다른 생성자로 생성할 수 있다.
- 매개변수가 같은 데이터형이더라도 개수가 다른 생성자를 만들 경우 다른 생성자로 생성할 수 있다.

3) this 사용방법
인스턴스 자기 자신을 참조하는 변수라는 의미이다
클래스의 멤버변수를 참조한다는 의미에서 구분해서 사용

// 기본생성(int 매개변수명)
1. this.멤버변수 = 매개변수명;
2. this(필드1, 필드2); // 묶어서 한번에 사용 가능
생성자, 같은 클래스

4) this 특징
- 같은 클래스 안에서 생성자가 다른 생성자를 호출할 때 사용
- 다른 생성자 호출 시 첫줄 사용
- 코드 중복을 막는다.

5) 생성자를 이용한 인스턴스 복사
참조변수를 매개변수로 받아서 인스턴스 변수 값을 복사한다.

소스코드)
Car car = new Car();
Car car2 = new Car(car); // 참조변수로 객체를 받는다.

인스턴스를 생성할 때 고려사항

1) 클래스 - 어떤 클래스의 인스턴스를 생성하냐
2) 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것이냐

@ 상속
부모의 클래스(설계도) 자식에게 물려줘서 자식은 부모(엄마 + 아빠)의 클래스와 나 자신의 클래스를
함께 구현할 수 있고 자식은 상속을 통해서 하나의 부모만 의존한다.
상속클래스 : 부모클래스 / 상위클래스 / 기반클래스
상속 받는 클래스 : 자식클래스 / 하위클래스 / 파생클래스

- 구현 방법

class A{	// 부모클래스

}

class B extends A{	// 자식클래스(B클래스는 의존한다)

}

1) super() 메서드(부모 기본 생성자)
부모 클래스의 생성자가 호출될 때 매개변수로 값을 전달 받아 부모 클래스의 필드들을 초기화 한다면
자식이 생성될 때 부모 생성자를 넣어줘야 한다.
- 기본 생성자가 호출되면 부모 기본 생성자(super)가 호출
- 부모 객체를 먼저 생성하고 자식 객체를 생성해야 한다.









